<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TuneJam - Collaborative Audio Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Socket.IO Client Library -->
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <!-- UUID library for anonymous user IDs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <!-- Firebase SDK for client-side Firestore, only if needed for direct access -->
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"></script>


    <style>
        /* Custom styles to enhance Tailwind's default behavior and provide specific overrides */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; /* Space between player and playlist */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Hide default audio controls */
        audio {
            display: none;
        }

        /* Custom range input styling for progress and volume bars */
        input[type="range"] {
            -webkit-appearance: none; /* Override default appearance */
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db; /* Light grey track */
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 5px; /* Rounded track */
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        /* Thumb styling for WebKit (Chrome, Safari) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4F46E5; /* Indigo thumb */
            cursor: pointer;
            border-radius: 50%; /* Circular thumb */
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            margin-top: -6px; /* Center thumb vertically */
        }

        /* Thumb styling for Firefox */
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4F46E5;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        /* Custom track styling for Firefox */
        input[type="range"]::-moz-range-track {
            background: #d1d5db;
            border-radius: 5px;
        }

        /* Styling for filled portion of the range input */
        .progress-bar-container input[type="range"] {
            background: linear-gradient(to right, #4F46E5 var(--progress, 0%), #d1d5db var(--progress, 0%));
        }
        .volume-bar-container input[type="range"] {
            background: linear-gradient(to right, #4F46E5 var(--volume, 100%), #d1d5db var(--volume, 100%));
        }

        /* Play/Pause button 'is-playing' animation */
        .play-pause-button.is-playing {
            animation: pulse-scale 1.5s infinite ease-in-out;
        }

        @keyframes pulse-scale {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 rgba(79, 70, 229, 0.7);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 15px rgba(79, 70, 229, 0.7);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 rgba(79, 70, 229, 0);
            }
        }

        /* Utility for icon size */
        .icon-size {
            font-size: 1.25rem; /* Smaller default icon size */
        }

        /* Playlist item active state */
        .playlist-item.current-song {
            background-color: #e0e7ff; /* Light indigo background */
            color: #4F46E5; /* Indigo text */
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            position: relative;
            animation: fadeIn 0.3s ease-out;
            max-height: 90vh; /* Limit modal height */
            overflow-y: auto; /* Enable scrolling for modal content */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .modal-close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            transition: color 0.2s;
        }

        .modal-close-button:hover {
            color: #ef4444; /* Red on hover */
        }

        /* Loading indicator styling */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #4F46E5;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom Message Box */
        #custom-message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #custom-message-box.show {
            opacity: 1;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            body {
                flex-direction: column; /* Stack player and playlist vertically */
                align-items: center;
                gap: 20px;
            }
            .audio-player-card, .playlist-card {
                width: 95%; /* Adjust width for smaller screens */
                max-width: 380px; /* Limit max width */
            }
            .icon-size {
                font-size: 1.1rem; /* Even smaller icon size on small screens */
            }
            .text-xl {
                font-size: 1rem; /* Adjust title size */
            }
            .text-sm {
                font-size: 0.7rem; /* Adjust duration font size */
            }
            .modal-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-50 to-purple-100 min-h-screen flex justify-center items-center p-4 relative">

    <div class="audio-player-card bg-white shadow-xl rounded-2xl p-6 md:p-8 w-full max-w-sm border border-gray-100">
        <h2 class="text-2xl md:text-3xl font-extrabold text-center text-gray-800 mb-6 tracking-tight">
            Music Player
        </h2>
        
        <div id="album-art-container" class="w-24 h-24 md:w-32 md:h-32 mx-auto mb-6 bg-gray-200 rounded-xl overflow-hidden shadow-md flex items-center justify-center">
            <img id="album-art" src="https://placehold.co/128x128/4F46E5/FFFFFF?text=Album+Art"
                 alt="Album Art" class="w-full h-full object-cover">
        </div>

        <div class="text-center mb-6">
            <h3 id="track-title" class="text-lg md:text-xl font-bold text-gray-900 truncate">Song Title Goes Here</h3>
            <p id="artist-name" class="text-xs md:text-sm text-gray-600 truncate">Artist Name</p>
        </div>

        <audio id="audio-player"></audio>

        <div class="progress-bar-container w-full mb-4">
            <input type="range" id="progress-bar" value="0" min="0" max="100" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-200">
            <div class="flex justify-between text-xs text-gray-600 mt-2">
                <span id="current-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
        </div>

        <div class="flex items-center justify-center space-x-4 mb-6">
            <button id="rewind-button" class="text-gray-700 hover:text-indigo-600 focus:outline-none transition-transform duration-200 ease-in-out active:scale-95">
                <i class="fas fa-backward icon-size"></i>
            </button>

            <button id="play-pause-button" class="w-14 h-14 md:w-16 md:h-16 bg-indigo-600 text-white rounded-full flex items-center justify-center shadow-lg hover:bg-indigo-700 focus:outline-none transition-all duration-300 ease-in-out">
                <i id="play-pause-icon" class="fas fa-play text-xl md:text-2xl"></i>
            </button>

            <button id="forward-button" class="text-gray-700 hover:text-indigo-600 focus:outline-none transition-transform duration-200 ease-in-out active:scale-95">
                <i class="fas fa-forward icon-size"></i>
            </button>

            <button id="next-button" class="text-gray-700 hover:text-indigo-600 focus:outline-none transition-transform duration-200 ease-in-out active:scale-95">
                <i class="fas fa-forward-step icon-size"></i>
            </button>
        </div>

        <div class="volume-bar-container flex items-center space-x-3 w-full">
            <i class="fas fa-volume-down text-gray-600 text-base"></i>
            <input type="range" id="volume-bar" value="100" min="0" max="100" class="flex-grow h-2 rounded-lg appearance-none cursor-pointer bg-gray-200">
            <i class="fas fa-volume-up text-gray-600 text-base"></i>
        </div>
        <!-- New button for playing random Hosted songs - MOVED HERE -->
        <div class="flex justify-center mt-6">
            <button id="play-random-hosted-songs-button" class="px-4 py-2 bg-purple-600 text-white rounded-lg shadow hover:bg-purple-700 transition-colors duration-200 text-sm">
                <i class="fas fa-random mr-2"></i>Play Random Songs
            </button>
        </div>
    </div>

    <div class="playlist-card bg-white shadow-xl rounded-2xl p-6 md:p-8 w-full max-w-sm border border-gray-100">
        <!-- Jam Session Info Display -->
        <div id="jam-session-info" class="text-center mb-4 hidden">
            <p class="text-indigo-600 font-bold text-lg" id="current-jam-name">Jam Session: <span id="jam-name-display"></span></p>
            <p class="text-gray-600 text-sm" id="jam-participants-display">Participants: </p>
            <button id="leave-jam-session-button" class="mt-2 px-3 py-1 bg-red-500 text-white rounded-md text-xs hover:bg-red-600 transition-colors duration-200">Leave Jam</button>
        </div>

        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl md:text-3xl font-extrabold text-gray-800 tracking-tight">
                Playlist
            </h2>
            <div class="relative flex items-center space-x-2">
                <!-- Three dots icon for Jam Session and Add Song options -->
                <button id="open-options-dropdown-button" class="px-3 py-2 bg-gray-600 text-white rounded-lg shadow hover:bg-gray-700 transition-colors duration-200 text-sm">
                    <i class="fas fa-ellipsis-v"></i> <!-- Three dots icon -->
                </button>
                <!-- Options dropdown -->
                <div id="options-dropdown" class="absolute right-0 top-full mt-2 w-48 bg-white rounded-md shadow-lg z-10 hidden">
                    <!-- These buttons are now always enabled as auth is removed -->
                    <button id="create-jam-session-dropdown-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                        <i class="fas fa-headphones mr-2"></i>Create Jam Session
                    </button>
                    <button id="join-jam-session-dropdown-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                        <i class="fas fa-door-open mr-2"></i>Join Jam Session
                    </button>
                </div>
            </div>
        </div>

        <div class="flex justify-center space-x-4 mb-6 flex-wrap">
            <!-- "Add Songs" button now opens the hosted MP3 search modal -->
            <button id="show-add-options-button" class="px-4 py-2 bg-green-600 text-white rounded-lg shadow hover:bg-green-700 transition-colors duration-200 text-sm">
                <i class="fas fa-plus mr-2"></i>Add Songs
            </button>
            <button id="manage-playlist-button" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg shadow hover:bg-gray-300 transition-colors duration-200 text-sm">
                <i class="fas fa-edit mr-2"></i>Manage Playlist
            </button>
        </div>

        <ul id="playlist-container" class="space-y-3 max-h-80 overflow-y-auto pr-2 mt-6 border-t border-gray-200 pt-6">
        </ul>
    </div>

    <!-- Modals -->
    <!-- Hosted MP3 Search Modal -->
    <div id="hosted-mp3-search-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-button" onclick="closeHostedMp3SearchModal()">×</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-6 text-center">Add MP3 Songs</h3>
            <div class="mb-6 pb-4">
                <p class="text-sm text-gray-600 mb-2">
                    Search from your pre-uploaded MP3 collection. Add multiple songs without closing.
                </p>
                <div class="flex space-x-2 mb-3">
                    <input type="text" id="hosted-mp3-search-input" placeholder="Search your songs by name/artist" class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500">
                    <button id="perform-hosted-mp3-search" class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors duration-200">
                        <i class="fas fa-search"></i>
                    </button>
                </div>
                <div id="hosted-mp3-search-results" class="max-h-60 overflow-y-auto space-y-2"></div>
            </div>
        </div>
    </div>

    <!-- Create Jam Session Modal -->
    <div id="create-jam-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-button" onclick="closeCreateJamModal()">×</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-6 text-center">Create New Jam Session</h3>
            <div class="mb-4">
                <label for="jam-name-input" class="block text-sm font-medium text-gray-700 mb-2">Jam Session Name (Optional)</label>
                <input type="text" id="jam-name-input" placeholder="My Awesome Jam" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div class="mb-6">
                <label for="nickname-input-create" class="block text-sm font-medium text-gray-700 mb-2">Your Nickname</label>
                <input type="text" id="nickname-input-create" placeholder="FunkyBeats" required class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <button id="create-jam-button" class="w-full bg-indigo-600 text-white py-2 rounded-md hover:bg-indigo-700 transition-colors duration-200">
                Create Jam
            </button>
        </div>
    </div>

    <!-- Join Jam Session Modal -->
    <div id="join-jam-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-button" onclick="closeJoinJamModal()">×</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-6 text-center">Join Jam Session</h3>
            <div class="mb-4">
                <label for="jam-id-input" class="block text-sm font-medium text-gray-700 mb-2">Jam Session ID</label>
                <input type="text" id="jam-id-input" placeholder="Paste ID here" required class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div class="mb-6">
                <label for="nickname-input-join" class="block text-sm font-medium text-gray-700 mb-2">Your Nickname</label>
                <input type="text" id="nickname-input-join" placeholder="CoolTune" required class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <button id="join-jam-button" class="w-full bg-indigo-600 text-white py-2 rounded-md hover:bg-indigo-700 transition-colors duration-200">
                Join Jam
            </button>
        </div>
    </div>

    <!-- Confirmation Modal (for leaving jam, etc.) -->
    <div id="confirmation-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="confirmation-title" class="text-xl font-bold text-gray-800 mb-4">Confirm Action</h3>
            <p id="confirmation-message" class="text-gray-700 mb-6">Are you sure you want to proceed?</p>
            <div class="flex justify-end space-x-4">
                <button id="confirm-cancel-button" class="px-4 py-2 bg-gray-300 text-gray-800 rounded-md hover:bg-gray-400">Cancel</button>
                <button id="confirm-action-button" class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Message Box -->
    <div id="custom-message-box" class="hidden"></div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="spinner"></div>
    </div>

    <script type="module">
        // Client-side JavaScript
        // Imports for Firebase removed as Auth is no longer used.
        // Firebase app and firestore are imported from CDN for client-side Firestore access.

        // Global variables for audio playback
        const audioPlayer = document.getElementById('audio-player');
        const progressBar = document.getElementById('progress-bar');
        const playPauseButton = document.getElementById('play-pause-button');
        const playPauseIcon = document.getElementById('play-pause-icon');
        const currentTimeSpan = document.getElementById('current-time');
        const totalTimeSpan = document.getElementById('total-time');
        const trackTitle = document.getElementById('track-title');
        const artistName = document.getElementById('artist-name');
        const albumArt = document.getElementById('album-art');
        const volumeBar = document.getElementById('volume-bar');
        const nextButton = document.getElementById('next-button');
        const rewindButton = document.getElementById('rewind-button');
        const forwardButton = document.getElementById('forward-button');
        const playRandomHostedSongsButton = document.getElementById('play-random-hosted-songs-button');

        // Playlist elements
        const playlistContainer = document.getElementById('playlist-container');
        const showAddOptionsButton = document.getElementById('show-add-options-button');
        const managePlaylistButton = document.getElementById('manage-playlist-button');

        // Modals and their buttons
        const hostedMp3SearchModal = document.getElementById('hosted-mp3-search-modal');
        const hostedMp3SearchInput = document.getElementById('hosted-mp3-search-input');
        const performHostedMp3SearchButton = document.getElementById('perform-hosted-mp3-search');
        const hostedMp3SearchResults = document.getElementById('hosted-mp3-search-results');
        const createJamModal = document.getElementById('create-jam-modal');
        const createJamButton = document.getElementById('create-jam-button');
        const jamNameInput = document.getElementById('jam-name-input');
        const nicknameInputCreate = document.getElementById('nickname-input-create');
        const joinJamModal = document.getElementById('join-jam-modal');
        const joinJamButton = document.getElementById('join-jam-button');
        const jamIdInput = document.getElementById('jam-id-input');
        const nicknameInputJoin = document.getElementById('nickname-input-join');
        const optionsDropdownButton = document.getElementById('open-options-dropdown-button');
        const optionsDropdown = document.getElementById('options-dropdown');
        const createJamSessionDropdownBtn = document.getElementById('create-jam-session-dropdown-btn');
        const joinJamSessionDropdownBtn = document.getElementById('join-jam-session-dropdown-btn');

        const jamSessionInfo = document.getElementById('jam-session-info');
        const jamNameDisplay = document.getElementById('jam-name-display');
        const jamParticipantsDisplay = document.getElementById('jam-participants-display');
        const leaveJamSessionButton = document.getElementById('leave-jam-session-button');

        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationTitle = document.getElementById('confirmation-title');
        const confirmationMessage = document.getElementById('confirmation-message');
        const confirmActionButton = document.getElementById('confirm-action-button');
        const confirmCancelButton = document.getElementById('confirm-cancel-button');

        const loadingOverlay = document.getElementById('loading-overlay');
        const customMessageBox = document.getElementById('custom-message-box');

        // Global state for music player and jam sessions
        let currentPlaylist = []; // This will be the active playlist, either local or jamSessionPlaylist
        let currentTrackIndex = -1;
        let isPlaying = false;
        let isShuffling = false; // New state for shuffling, controlled by random play button
        let currentJamId = null;
        let isHost = false;
        // Generate a persistent local ID for anonymous users
        let userId = localStorage.getItem('tunejam_userId') || uuidv4();
        localStorage.setItem('tunejam_userId', userId); // Save it for future sessions
        let currentNickname = localStorage.getItem('tunejam_nickname') || `Guest-${Math.floor(Math.random() * 1000)}`;

        const SOCKET_URL = window.location.origin; // Use the current origin for Socket.IO connection
        // Pass userId as a query parameter for server-side logging/tracking
        const socket = io(SOCKET_URL, {
            query: {
                userId: userId // Pass the persistent anonymous ID
            }
        });

        // Firebase client-side Firestore for listening to updates
        let fbApp;
        let db; // Client-side Firestore instance

        // Firestore unsubscribe function placeholder
        let unsubscribeJamListener = null;
        let syncInterval = null; // Interval for host to send playback updates

        // --- NEW GLOBAL STATE FOR RANDOM PLAYBACK (for hosted MP3s) ---
        let fullHostedSongsList = []; // Stores all fetched songs from hosted_songs_manifest.json
        const RANDOM_QUEUE_SIZE = 5; // Desired number of songs in the dynamic random queue

        // Function to show custom message
        function showMessage(message, duration = 3000) {
            customMessageBox.textContent = message;
            customMessageBox.classList.add('show');
            customMessageBox.classList.remove('hidden');
            clearTimeout(customMessageBox.messageTimeout); // Clear any existing timeout
            customMessageBox.messageTimeout = setTimeout(() => {
                customMessageBox.classList.remove('show');
                customMessageBox.classList.add('hidden');
            }, duration);
        }

        // Function to show/hide loading overlay
        function showLoading(show) {
            if (show) {
                loadingOverlay.classList.remove('hidden');
            } else {
                loadingOverlay.classList.add('hidden');
            }
        }

        // --- Audio Player Functions ---
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "0:00";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        function loadTrack(index, autoPlay = true, seekTime = 0) {
            if (index >= 0 && index < currentPlaylist.length) {
                currentTrackIndex = index;
                const track = currentPlaylist[currentTrackIndex];
                audioPlayer.src = track.url;
                trackTitle.textContent = track.title;
                artistName.textContent = track.artist || 'Unknown Artist';
                albumArt.src = track.thumbnail || 'https://placehold.co/128x128/4F46E5/FFFFFF?text=Album+Art';
                albumArt.onerror = () => { // Fallback for broken image links
                    albumArt.src = "https://placehold.co/128x128/CCCCCC/FFFFFF?text=Error";
                };
                audioPlayer.load(); // Load the new track
                audioPlayer.currentTime = seekTime;

                renderPlaylist(); // Re-render to highlight the current song

                // Host handles play/pause; participants follow host via sync
                if (autoPlay) {
                    audioPlayer.play().catch(e => console.error("Error playing audio:", e));
                    isPlaying = true;
                } else {
                    audioPlayer.pause();
                    isPlaying = false;
                }
                updatePlayPauseButtonUI();

                if (currentJamId && isHost) {
                    // Host sets play/pause state; participants follow host
                    socket.emit('sync_playback_state', {
                        jam_id: currentJamId,
                        current_track_index: currentTrackIndex,
                        current_playback_time: audioPlayer.currentTime,
                        is_playing: isPlaying,
                        playlist: currentPlaylist // Host's playlist is the source of truth
                    });
                }
            } else {
                // No more songs or invalid index
                currentTrackIndex = -1;
                audioPlayer.src = '';
                trackTitle.textContent = 'No Song Playing';
                artistName.textContent = '';
                albumArt.src = 'https://placehold.co/128x128/4F46E5/FFFFFF?text=Album+Art';
                playPauseIcon.classList.remove('fa-pause');
                playPauseIcon.classList.add('fa-play');
                playPauseButton.classList.remove('is-playing');
                isPlaying = false;
                audioPlayer.pause();
                audioPlayer.currentTime = 0; // Reset time if playlist ends

                if (currentJamId && isHost) {
                    // If host and playlist ended, sync state to pause everyone
                    socket.emit('sync_playback_state', {
                        jam_id: currentJamId,
                        current_track_index: -1, // Indicate end of playlist
                        current_playback_time: 0,
                        is_playing: false,
                        playlist: currentPlaylist // Send the final playlist state
                    });
                } else if (!currentJamId && isShuffling) {
                    // If local random playback ends, disable shuffling
                    isShuffling = false;
                    showMessage("Random playback ended. Add more songs or start new random play.", 5000);
                }
                renderPlaylist();
            }
        }

        function playPauseToggle() {
            if (audioPlayer.paused || audioPlayer.ended) {
                audioPlayer.play();
            } else {
                audioPlayer.pause();
            }
            isPlaying = !audioPlayer.paused; // Update local state immediately
            updatePlayPauseButtonUI();

            if (currentJamId && isHost) {
                // Only host emits sync_playback_state for play/pause
                socket.emit('sync_playback_state', {
                    jam_id: currentJamId,
                    current_track_index: currentTrackIndex,
                    current_playback_time: audioPlayer.currentTime,
                    is_playing: isPlaying,
                    playlist: currentPlaylist
                });
            }
        }

        function updatePlayPauseButtonUI() {
            if (isPlaying) {
                playPauseIcon.classList.remove('fa-play');
                playPauseIcon.classList.add('fa-pause');
                playPauseButton.classList.add('is-playing');
            } else {
                playPauseIcon.classList.remove('fa-pause');
                playPauseIcon.classList.add('fa-play');
                playPauseButton.classList.remove('is-playing');
            }
        }

        function nextSong() {
            if (currentPlaylist.length === 0) {
                showMessage("Playlist is empty.");
                return;
            }

            if (currentJamId && !isHost) {
                showMessage("Only the host can change the song in a jam session.");
                return;
            }

            let nextIndex;
            if (isShuffling) {
                // Pick a random song from the playlist
                nextIndex = Math.floor(Math.random() * currentPlaylist.length);
                // Ensure it's not the same song unless it's the only one
                if (currentPlaylist.length > 1 && nextIndex === currentTrackIndex) {
                    nextIndex = (nextIndex + 1) % currentPlaylist.length;
                }
            } else {
                nextIndex = currentTrackIndex + 1;
                if (nextIndex >= currentPlaylist.length) {
                    nextIndex = 0; // Loop back to the start
                }
            }
            
            // Host performs the actual load and sync
            loadTrack(nextIndex, true); // Autoplay next song

            if (currentJamId && isHost) {
                socket.emit('sync_playback_state', {
                    jam_id: currentJamId,
                    current_track_index: nextIndex,
                    current_playback_time: audioPlayer.currentTime,
                    is_playing: isPlaying,
                    playlist: currentPlaylist
                });
            }
        }

        function previousSong() {
            if (currentPlaylist.length === 0) {
                showMessage("Playlist is empty.");
                return;
            }
            if (currentJamId && !isHost) {
                showMessage("Only the host can change the song in a jam session.");
                return;
            }

            // If current time is past 3 seconds, restart current song
            if (audioPlayer.currentTime > 3) {
                audioPlayer.currentTime = 0;
            } else {
                // Otherwise, go to previous song
                let prevIndex = currentTrackIndex - 1;
                if (prevIndex < 0) {
                    prevIndex = currentPlaylist.length - 1; // Loop to end
                }
                loadTrack(prevIndex, true); // Autoplay previous song
            }
            
            if (currentJamId && isHost) {
                socket.emit('sync_playback_state', {
                    jam_id: currentJamId,
                    current_track_index: currentTrackIndex,
                    current_playback_time: audioPlayer.currentTime,
                    is_playing: isPlaying,
                    playlist: currentPlaylist
                });
            }
        }

        // --- Event Listeners for Audio Player Controls ---
        playPauseButton.addEventListener('click', playPauseToggle);
        nextButton.addEventListener('click', nextSong);
        rewindButton.addEventListener('click', () => {
            if (currentJamId && !isHost) {
                showMessage("Only the host can control playback in a jam session.");
                return;
            }
            audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 10); // Rewind 10 seconds
            if (currentJamId && isHost) {
                socket.emit('sync_playback_state', {
                    jam_id: currentJamId,
                    current_track_index: currentTrackIndex,
                    current_playback_time: audioPlayer.currentTime,
                    is_playing: audioPlayer.paused ? false : true,
                    playlist: currentPlaylist
                });
            }
        });
        forwardButton.addEventListener('click', () => {
            if (currentJamId && !isHost) {
                showMessage("Only the host can control playback in a jam session.");
                return;
            }
            audioPlayer.currentTime = Math.min(audioPlayer.duration, audioPlayer.currentTime + 10); // Fast forward 10 seconds
            if (currentJamId && isHost) {
                socket.emit('sync_playback_state', {
                    jam_id: currentJamId,
                    current_track_index: currentTrackIndex,
                    current_playback_time: audioPlayer.currentTime,
                    is_playing: audioPlayer.paused ? false : true,
                    playlist: currentPlaylist
                });
            }
        });

        // --- Random Playback (Hosted Songs) ---
        playRandomHostedSongsButton.addEventListener('click', async () => {
            if (currentJamId) {
                showMessage("Random playback is not available when in a Jam Session. Only host can control.", 3000);
                return;
            }

            if (fullHostedSongsList.length === 0) {
                await fetchAllHostedSongsForRandomPlayback(); 
                if (fullHostedSongsList.length === 0) {
                    showMessage("No hosted songs available to start random playback. Please check `hosted_songs_manifest.json`.", 5000);
                    resetPlayerUI();
                    isShuffling = false;
                    return;
                }
            }
            
            isShuffling = true; // Enable shuffling for local playback
            currentPlaylist = []; // Clear current local playlist
            
            // Populate initial random queue
            const availableSongs = [...fullHostedSongsList]; // Create a mutable copy
            for (let i = 0; i < RANDOM_QUEUE_SIZE && availableSongs.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableSongs.length);
                currentPlaylist.push(availableSongs.splice(randomIndex, 1)[0]); // Add and remove to ensure uniqueness in initial queue
            }
            
            renderPlaylist(); // Render the new random queue
            if (currentPlaylist.length > 0) {
                currentTrackIndex = 0; // Start with the first song in the newly created queue
                loadTrack(currentTrackIndex, true);
                showMessage(`Starting random play with ${currentPlaylist.length} songs from your hosted collection!`, 3000);
            } else {
                showMessage("Could not populate initial random queue. Try adding songs manually.", 3000);
                resetPlayerUI();
                isShuffling = false;
            }
        });


        audioPlayer.addEventListener('timeupdate', () => {
            const progress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
            progressBar.value = progress;
            progressBar.style.setProperty('--progress', `${progress}%`);
            currentTimeSpan.textContent = formatTime(audioPlayer.currentTime);
            totalTimeSpan.textContent = formatTime(audioPlayer.duration);
        });

        audioPlayer.addEventListener('ended', () => {
            // If the current song ends, and we are the host OR playing locally, advance to the next song
            if ((currentJamId && isHost) || !currentJamId) {
                nextSong();
            }
        });

        progressBar.addEventListener('input', () => {
            // Only host can seek
            if (currentJamId && !isHost) {
                showMessage("Only the host can seek in a jam session.");
                // Reset progress bar visually if not host
                const currentProgress = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                progressBar.value = currentProgress;
                progressBar.style.setProperty('--progress', `${currentProgress}%`);
                return;
            }
            const seekTime = (progressBar.value / 100) * audioPlayer.duration;
            audioPlayer.currentTime = seekTime;
            // Sync immediately after seeking if in a jam and host
            if (currentJamId && isHost) {
                socket.emit('sync_playback_state', {
                    jam_id: currentJamId,
                    current_track_index: currentTrackIndex,
                    current_playback_time: audioPlayer.currentTime,
                    is_playing: audioPlayer.paused ? false : true, // Send current playing state
                    playlist: currentPlaylist
                });
            }
        });

        volumeBar.addEventListener('input', () => {
            audioPlayer.volume = volumeBar.value / 100;
            volumeBar.style.setProperty('--volume', `${volumeBar.value}%`);
        });

        // Set initial volume
        audioPlayer.volume = volumeBar.value / 100;
        volumeBar.style.setProperty('--volume', `${volumeBar.value}%`);


        // --- Playlist Management Functions ---

        function renderPlaylist() {
            playlistContainer.innerHTML = ''; // Clear existing playlist
            if (currentPlaylist.length === 0) {
                const emptyItem = document.createElement('li');
                emptyItem.className = 'text-center text-gray-500 py-4';
                emptyItem.textContent = 'Playlist is empty. Add some songs!';
                playlistContainer.appendChild(emptyItem);
                return;
            }

            currentPlaylist.forEach((song, index) => {
                const listItem = document.createElement('li');
                listItem.className = `playlist-item flex items-center justify-between p-3 rounded-lg cursor-pointer transition-all duration-200 ease-in-out hover:bg-gray-100 ${index === currentTrackIndex ? 'current-song' : 'bg-white shadow-sm'}`;
                listItem.dataset.index = index;
                listItem.id = `playlist-item-${index}`; // Add ID for direct selection

                listItem.innerHTML = `
                    <div class="flex-grow flex items-center space-x-3">
                        <img src="${song.thumbnail || 'https://placehold.co/40x40/CCCCCC/FFFFFF?text=MP3'}" alt="Thumbnail" class="w-10 h-10 rounded-md object-cover flex-shrink-0">
                        <div class="flex-grow overflow-hidden">
                            <p class="text-sm font-semibold text-gray-800 truncate">${song.title}</p>
                            <p class="text-xs text-gray-500 truncate">${song.artist || 'Unknown Artist'}</p>
                        </div>
                    </div>
                    <div class="flex-shrink-0 text-xs text-gray-500 ml-4">
                        ${formatTime(song.duration)}
                    </div>
                    <button class="remove-song-button ml-2 text-red-500 hover:text-red-700 p-1 rounded-full focus:outline-none transition-colors duration-200 ${currentJamId && !isHost ? 'opacity-50 cursor-not-allowed' : ''}" ${currentJamId && !isHost ? 'disabled' : ''}>
                        <i class="fas fa-times"></i>
                    </button>
                `;

                // Play song on click
                listItem.querySelector('.flex-grow').addEventListener('click', () => {
                    if (currentJamId && !isHost) {
                        showMessage("Only the host can change the song in a jam session.");
                        return;
                    }
                    isShuffling = false; // Disable shuffling if user manually selects a song
                    loadTrack(index, true); // Autoplay
                    if (currentJamId && isHost) {
                        socket.emit('sync_playback_state', {
                            jam_id: currentJamId,
                            current_track_index: index,
                            current_playback_time: audioPlayer.currentTime,
                            is_playing: isPlaying,
                            playlist: currentPlaylist
                        });
                    }
                });

                // Remove song button logic
                listItem.querySelector('.remove-song-button').addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent listItem click event
                    if (currentJamId && !isHost) {
                        showMessage("Only the host can remove songs from the playlist in a jam session.");
                        return;
                    }
                    confirmAction("Remove Song", "Are you sure you want to remove this song from the playlist?", () => {
                        removeSongFromPlaylist(song.id); // Pass song ID
                    });
                });

                playlistContainer.appendChild(listItem);
            });
        }

        async function removeSongFromPlaylist(songIdToRemove) {
            let indexToRemove = -1;
            for (let i = 0; i < currentPlaylist.length; i++) {
                if (currentPlaylist[i].id === songIdToRemove) {
                    indexToRemove = i;
                    break;
                }
            }

            if (indexToRemove === -1) {
                console.warn(`Song with ID ${songIdToRemove} not found in current playlist.`);
                return;
            }

            const removedSong = currentPlaylist.splice(indexToRemove, 1)[0];
            showMessage(`Removed "${removedSong.title}" from playlist.`, 2000);

            if (currentJamId && isHost) {
                // If host, notify server to remove
                socket.emit('remove_song_from_jam', { jam_id: currentJamId, song_id: songIdToRemove });
                // Adjust currentTrackIndex if the removed song was before or was the current song
                if (currentTrackIndex === indexToRemove) {
                    // If current song is removed, try to play the next one or reset
                    if (currentPlaylist.length > 0) {
                        loadTrack(Math.min(currentTrackIndex, currentPlaylist.length - 1), isPlaying);
                    } else {
                        loadTrack(-1); // Empty playlist
                    }
                } else if (currentTrackIndex > indexToRemove) {
                    currentTrackIndex--; // Shift index if song removed before current one
                }
                renderPlaylist();
                // Re-sync after playlist change
                socket.emit('sync_playback_state', {
                    jam_id: currentJamId,
                    current_track_index: currentTrackIndex,
                    current_playback_time: audioPlayer.currentTime,
                    is_playing: isPlaying,
                    playlist: currentPlaylist
                });
            } else if (!currentJamId) {
                // Not in a jam, remove locally only
                if (currentTrackIndex === indexToRemove) {
                    if (currentPlaylist.length > 0) {
                        loadTrack(Math.min(currentTrackIndex, currentPlaylist.length - 1), isPlaying);
                    } else {
                        loadTrack(-1); // Empty playlist
                    }
                } else if (currentTrackIndex > indexToRemove) {
                    currentTrackIndex--; // Shift index if song removed before current one
                }
                renderPlaylist();
            } else {
                showMessage("Only the host can remove songs from the playlist in a jam session.");
            }
        }

        managePlaylistButton.addEventListener('click', () => {
            // Toggle visibility of remove buttons
            document.querySelectorAll('.remove-song-button').forEach(button => {
                if (currentJamId && !isHost) {
                    // If in jam and not host, keep disabled/hidden
                    return;
                }
                button.classList.toggle('hidden');
            });
            // Change button text
            if (managePlaylistButton.textContent.includes('Manage')) {
                managePlaylistButton.innerHTML = '<i class="fas fa-check mr-2"></i>Done Managing';
            } else {
                managePlaylistButton.innerHTML = '<i class="fas fa-edit mr-2"></i>Manage Playlist';
            }
        });


        // --- Modal Functions ---
        function openModal(modal) {
            modal.classList.remove('hidden');
        }

        function closeModal(modal) {
            modal.classList.add('hidden');
        }

        function closeHostedMp3SearchModal() {
            closeModal(hostedMp3SearchModal);
            hostedMp3SearchInput.value = '';
            hostedMp3SearchResults.innerHTML = '';
        }

        function closeCreateJamModal() {
            closeModal(createJamModal);
            jamNameInput.value = '';
            nicknameInputCreate.value = '';
        }

        function closeJoinJamModal() {
            closeModal(joinJamModal);
            jamIdInput.value = '';
            nicknameInputJoin.value = '';
        }

        function confirmAction(title, message, onConfirm) {
            confirmationTitle.textContent = title;
            confirmationMessage.textContent = message;
            openModal(confirmationModal);

            const handleConfirm = () => {
                onConfirm();
                confirmActionButton.removeEventListener('click', handleConfirm);
                confirmCancelButton.removeEventListener('click', handleCancel);
                closeModal(confirmationModal);
            };

            const handleCancel = () => {
                confirmActionButton.removeEventListener('click', handleConfirm);
                confirmCancelButton.removeEventListener('click', handleCancel);
                closeModal(confirmationModal);
            };

            confirmActionButton.addEventListener('click', handleConfirm);
            confirmCancelButton.addEventListener('click', handleCancel);
        }

        // Event listener for opening the main options dropdown
        optionsDropdownButton.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent click from immediately closing it
            optionsDropdown.classList.toggle('hidden');
        });

        // Close dropdown if clicked outside
        document.addEventListener('click', (event) => {
            if (!optionsDropdown.contains(event.target) && !optionsDropdownButton.contains(event.target)) {
                optionsDropdown.classList.add('hidden');
            }
        });

        // Open create jam modal
        createJamSessionDropdownBtn.addEventListener('click', () => {
            closeModal(optionsDropdown);
            openModal(createJamModal);
            nicknameInputCreate.value = currentNickname; // Pre-fill nickname
        });

        // Open join jam modal
        joinJamSessionDropdownBtn.addEventListener('click', () => {
            closeModal(optionsDropdown);
            openModal(joinJamModal);
            nicknameInputJoin.value = currentNickname; // Pre-fill nickname
        });

        // Show "Add Song" modal
        showAddOptionsButton.addEventListener('click', () => {
            openModal(hostedMp3SearchModal);
            // Pre-fill search results with all songs if no query
            performHostedMp3Search(''); // Empty query to show all
        });


        // --- Jam Session Functions ---

        function updateJamSessionUI(jamId, jamName, participants, isHostStatus) {
            currentJamId = jamId;
            isHost = isHostStatus;
            jamSessionInfo.classList.remove('hidden');
            jamNameDisplay.textContent = jamName;

            // Update participants list
            const participantNames = Object.values(participants).join(', ');
            jamParticipantsDisplay.textContent = `Participants: ${participantNames}`;

            // Adjust UI based on host status
            if (isHost) {
                showMessage(`You are the host of Jam Session "${jamName}"!`, 4000);
            } else {
                showMessage(`Joined Jam Session "${jamName}". You are a participant.`, 4000);
            }
            // Update nickname display in currentNicknameSpan (if exists)
            const currentNicknameSpan = document.getElementById('current-nickname');
            if (currentNicknameSpan) {
                currentNicknameSpan.textContent = `(${currentNickname})`;
            }

            // Hide dropdown buttons once in a jam
            createJamSessionDropdownBtn.classList.add('hidden');
            joinJamSessionDropdownBtn.classList.add('hidden');
            
            // Enable/disable controls based on host status
            playPauseButton.disabled = !isHost;
            progressBar.disabled = !isHost;
            nextButton.disabled = !isHost;
            rewindButton.disabled = !isHost;
            forwardButton.disabled = !isHost;
            playRandomHostedSongsButton.disabled = !isHost; // Only host can initiate random play in jam

            managePlaylistButton.disabled = !isHost;
            
            // Toggle opacity/cursor classes for visual feedback
            [playPauseButton, progressBar, nextButton, rewindButton, forwardButton, playRandomHostedSongsButton, managePlaylistButton].forEach(btn => {
                if (btn) {
                    if (!isHost) {
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                    } else {
                        btn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }
            });

            // Re-render playlist to update remove buttons visibility/state
            renderPlaylist(); 
        }

        function resetPlayerUI() {
            currentJamId = null;
            isHost = false;
            currentPlaylist = []; // Clear local playlist
            currentTrackIndex = -1;
            isPlaying = false;
            isShuffling = false; // Reset shuffling state
            audioPlayer.src = '';
            trackTitle.textContent = 'No Song Playing';
            artistName.textContent = '';
            albumArt.src = 'https://placehold.co/128x128/4F46E5/FFFFFF?text=Album+Art';
            progressBar.value = 0;
            progressBar.style.setProperty('--progress', `0%`);
            currentTimeSpan.textContent = '0:00';
            totalTimeSpan.textContent = '0:00';
            updatePlayPauseButtonUI();
            renderPlaylist(); // Clear playlist display
            jamSessionInfo.classList.add('hidden');

            // Re-enable all controls and dropdown options for local use
            playPauseButton.disabled = false;
            progressBar.disabled = false;
            nextButton.disabled = false;
            rewindButton.disabled = false;
            forwardButton.disabled = false;
            playRandomHostedSongsButton.disabled = false;

            managePlaylistButton.disabled = false;
            document.querySelectorAll('.remove-song-button').forEach(btn => {
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
                btn.disabled = false;
                btn.classList.add('hidden'); // Hide remove buttons by default
            });

            // Remove disabled styling from dropdown buttons
            createJamSessionDropdownBtn.classList.remove('hidden');
            joinJamSessionDropdownBtn.classList.remove('hidden');

            // Ensure disabled attributes are removed for these specific elements
            createJamSessionDropdownBtn.disabled = false;
            createJamSessionDropdownBtn.classList.remove('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
            joinJamSessionDropdownBtn.disabled = false;
            joinJamSessionDropdownBtn.classList.remove('opacity-70', 'cursor-not-allowed', 'pointer-events-none');

            // Reset nickname inputs in modals
            nicknameInputCreate.value = localStorage.getItem('tunejam_nickname') || `Guest-${Math.floor(Math.random() * 1000)}`;
            nicknameInputJoin.value = localStorage.getItem('tunejam_nickname') || `Guest-${Math.floor(Math.random() * 1000)}`;
        }

        // Event listener for creating a jam session
        createJamButton.addEventListener('click', () => {
            const jamName = jamNameInput.value.trim();
            let nickname = nicknameInputCreate.value.trim();

            if (!nickname) {
                nickname = `Guest-${Math.floor(Math.random() * 1000)}`; // Generate if empty
            }
            currentNickname = nickname; // Update global nickname
            localStorage.setItem('tunejam_nickname', currentNickname); // Save to local storage

            showLoading(true);
            // Pass the persistent userId to the backend
            socket.emit('create_session', { jam_name: jamName, nickname: currentNickname, userId: userId });
            closeCreateJamModal();
        });

        // Event listener for joining a jam session
        joinJamButton.addEventListener('click', () => {
            const jamId = jamIdInput.value.trim();
            let nickname = nicknameInputJoin.value.trim();

            if (!jamId) {
                showMessage("Please enter a Jam Session ID.", 3000);
                return;
            }
            if (!nickname) {
                nickname = `Guest-${Math.floor(Math.random() * 1000)}`; // Generate if empty
            }
            currentNickname = nickname; // Update global nickname
            localStorage.setItem('tunejam_nickname', currentNickname); // Save to local storage

            showLoading(true);
            // Pass the persistent userId to the backend
            socket.emit('join_session', { jam_id: jamId, nickname: currentNickname, userId: userId });
            closeJoinJamModal();
        });

        leaveJamSessionButton.addEventListener('click', () => {
            confirmAction("Leave Jam Session", "Are you sure you want to leave this jam session?", () => {
                if (currentJamId) {
                    socket.emit('leave_session', { jam_id: currentJamId });
                    resetPlayerUI();
                    clearInterval(syncInterval);
                    if (unsubscribeJamListener) {
                        unsubscribeJamListener();
                        unsubscribeJamListener = null;
                    }
                    showMessage("You have left the jam session.");
                    window.history.pushState({}, '', `/`); // Clear jam_id from URL
                }
            });
        });

        // --- Socket.IO Event Handlers (Client-Side) ---

        socket.on('connect', () => {
            console.log('Connected to Socket.IO server with ID:', socket.id);
            // Buttons are always enabled as auth is removed
            createJamSessionDropdownBtn.disabled = false;
            createJamSessionDropdownBtn.classList.remove('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
            joinJamSessionDropdownBtn.disabled = false;
            joinJamSessionDropdownBtn.classList.remove('opacity-70', 'cursor-not-allowed', 'pointer-events-none');

            // Handle initial load and potential jam join via URL
            handleInitialLoadAndJamJoin();
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from Socket.IO server.');
            showMessage("Disconnected from server. Jam features may be unavailable.", 5000);
            resetPlayerUI(); // Reset UI on disconnect
            clearInterval(syncInterval);
            if (unsubscribeJamListener) {
                unsubscribeJamListener();
                unsubscribeJamListener = null;
            }
            window.history.pushState({}, '', `/`); // Clear jam_id from URL
        });

        socket.on('session_created', (data) => {
            showLoading(false);
            showMessage(`Jam session "${data.jam_name}" created! ID: ${data.jam_id}. Share this link: ${data.shareable_link}`, 10000);
            currentJamId = data.jam_id;
            isHost = true;
            // userId = data.userId; // No need to update userId, it's already localUserId

            currentPlaylist = []; // Start with an empty playlist for the new jam
            updateJamSessionUI(data.jam_id, data.jam_name, data.participants, true);
            // Start listening for Firestore updates for this jam session
            startJamFirestoreListener(data.jam_id);
            startHostSyncInterval(); // Host starts syncing

            // Update the URL in the browser's history to include the jam ID
            window.history.pushState({ jam_id: currentJamId }, '', `/?jam_id=${currentJamId}`);
        });

        socket.on('session_join_success', (data) => {
            showLoading(false);
            showMessage(`Successfully joined jam session "${data.jam_name}".`, 5000);
            currentJamId = data.jam_id;
            isHost = (socket.id === data.host_sid); // Verify host status
            // userId = data.userId; // No need to update userId

            currentPlaylist = data.playlist || []; // Sync playlist from jam session
            updateJamSessionUI(data.jam_id, data.jam_name, data.participants, isHost);
            loadTrack(data.current_track_index, data.is_playing, data.current_playback_time); // Load track from synced state

            // Participants listen for Firestore updates, host also listens for changes
            startJamFirestoreListener(data.jam_id);
            if (isHost) {
                startHostSyncInterval();
            }
            // Update the URL in the browser's history to include the jam ID
            window.history.pushState({ jam_id: currentJamId }, '', `/?jam_id=${currentJamId}`);
        });

        socket.on('join_failed', (data) => {
            showLoading(false);
            showMessage(`Failed to join jam session: ${data.message}`, 5000);
            resetPlayerUI(); // Ensure UI is reset on failure
        });

        socket.on('update_participants', (data) => {
            if (currentJamId === data.jam_id) {
                const participantNames = Object.values(data.participants).join(', ');
                jamParticipantsDisplay.textContent = `Participants: ${participantNames}`;
                
                const wasHostBeforeUpdate = isHost; // Store current host status
                isHost = (socket.id === data.new_host_sid); // Check if YOU are the new host

                if (!wasHostBeforeUpdate && isHost) {
                    showMessage("You are now the host of this jam session!", 6000);
                    updateJamSessionUI(currentJamId, jamNameDisplay.textContent, data.participants, true);
                    startHostSyncInterval(); // New host starts syncing
                } else if (wasHostBeforeUpdate && !isHost) {
                    // Current host is no longer the host (e.g., someone else took over or host disconnected)
                    showMessage("Host has changed. You are now a participant.", 6000);
                    updateJamSessionUI(currentJamId, jamNameDisplay.textContent, data.participants, false);
                    clearInterval(syncInterval); // Stop syncing if no longer host
                    audioPlayer.pause(); // Participants don't drive playback
                    isPlaying = false;
                    updatePlayPauseButtonUI();
                } else {
                    // Update UI for participant changes without host change
                    updateJamSessionUI(currentJamId, jamNameDisplay.textContent, data.participants, isHost);
                }
            }
        });

        socket.on('session_ended', (data) => {
            showLoading(false);
            showMessage(data.message, 5000);
            resetPlayerUI();
            clearInterval(syncInterval);
            if (unsubscribeJamListener) {
                unsubscribeJamListener();
                unsubscribeJamListener = null;
            }
            window.history.pushState({}, '', `/`); // Clear jam_id from URL
        });

        // --- Firebase Client-Side Firestore Realtime Listener for Jam Session Data ---
        // This function sets up a Firestore real-time listener for the active jam session.
        // It will update the client's playlist and playback state whenever the Firestore document changes.
        async function startJamFirestoreListener(jamId) {
            // Ensure client-side Firestore is initialized before attempting to listen
            if (!db) {
                console.error("Client-side Firestore not initialized. Cannot listen for jam updates.");
                return;
            }

            // Correct Firestore path for public data: artifacts/{APP_ID}/public/data/jam_sessions
            const jamDocRef = db.collection('artifacts').doc('tunejam-app').collection('public').doc('data').collection('jam_sessions').doc(jamId);

            // Unsubscribe from any previous listener to prevent memory leaks
            if (unsubscribeJamListener) {
                unsubscribeJamListener();
            }

            unsubscribeJamListener = jamDocRef.onSnapshot((docSnapshot) => {
                if (docSnapshot.exists) {
                    const jamData = docSnapshot.data();
                    console.log("Firestore update received for jam:", jamData);

                    // Update local state based on Firestore data
                    currentPlaylist = jamData.playlist || []; // Directly update currentPlaylist for jam sessions
                    const playback = jamData.playback_state || { current_track_index: -1, current_playback_time: 0, is_playing: false, timestamp: { seconds: 0 } };

                    // Determine host status based on server's host_sid
                    const wasHostBeforeUpdate = isHost;
                    isHost = (socket.id === jamData.host_sid);

                    // If not the host, update playback and playlist
                    if (!isHost) {
                        // Load track if different or if no track is loaded
                        if (currentTrackIndex !== playback.current_track_index || audioPlayer.src === '') {
                             loadTrack(playback.current_track_index, playback.is_playing, playback.current_playback_time);
                        } else {
                            // Only adjust playback time if significant desync or paused->playing transition
                            const lastSyncedTime = playback.timestamp ? playback.timestamp.seconds : 0;
                            const serverCurrentTime = playback.current_playback_time + (Date.now() / 1000 - lastSyncedTime);

                            // Only seek if difference is more than a threshold (e.g., 0.75 seconds)
                            if (Math.abs(audioPlayer.currentTime - serverCurrentTime) > 0.75) {
                                audioPlayer.currentTime = serverCurrentTime;
                            }

                            if (playback.is_playing && audioPlayer.paused) {
                                audioPlayer.play().catch(e => console.error("Error playing audio (guest sync):", e));
                                isPlaying = true;
                            } else if (!playback.is_playing && !audioPlayer.paused) {
                                audioPlayer.pause();
                                isPlaying = false;
                            }
                            updatePlayPauseButtonUI();
                        }
                    }
                    // Always re-render playlist and update UI for all participants
                    renderPlaylist();
                    updateJamSessionUI(currentJamId, jamData.name, jamData.participants, isHost);

                    // If you *became* the host through this update
                    if (!wasHostBeforeUpdate && isHost) {
                        startHostSyncInterval(); // New host starts syncing
                    } else if (wasHostBeforeUpdate && !isHost) {
                        // If you *stopped* being the host
                        clearInterval(syncInterval); // Stop syncing
                        audioPlayer.pause(); // Participants don't drive playback
                        isPlaying = false;
                        updatePlayPauseButtonUI();
                    }

                } else {
                    // Document does not exist, jam session might have ended
                    showMessage("Jam session has ended or no longer exists.", 5000);
                    resetPlayerUI();
                    clearInterval(syncInterval);
                    if (unsubscribeJamListener) {
                        unsubscribeJamListener();
                        unsubscribeJamListener = null;
                    }
                    window.history.pushState({}, '', `/`); // Clear jam_id from URL
                }
            }, (error) => {
                console.error("Firestore listener error:", error);
                showMessage("Real-time updates failed. Jam features may be unstable.", 5000);
                resetPlayerUI(); // Reset UI on error
                clearInterval(syncInterval);
                if (unsubscribeJamListener) {
                    unsubscribeJamListener();
                    unsubscribeJamListener = null;
                }
                window.history.pushState({}, '', `/`); // Clear jam_id from URL
            });
            console.log(`Started Firestore listener for jam: ${jamId}`);
        }

        // Host sends regular playback updates to Firestore
        function startHostSyncInterval() {
            if (syncInterval) {
                clearInterval(syncInterval); // Clear any existing interval
            }
            syncInterval = setInterval(() => {
                if (isHost && currentJamId && audioPlayer) {
                    socket.emit('sync_playback_state', {
                        jam_id: currentJamId,
                        current_track_index: currentTrackIndex,
                        current_playback_time: audioPlayer.currentTime,
                        is_playing: isPlaying,
                        playlist: currentPlaylist // Host sends the current state of its playlist
                    });
                } else if (!isHost && syncInterval) {
                    // If somehow we are no longer host, stop the interval
                    clearInterval(syncInterval);
                    syncInterval = null;
                }
            }, 1000); // Sync every 1 second
            console.log("Host sync interval started.");
        }


        // Function to load all hosted songs (for search modal and random play)
        async function performHostedMp3Search(query) {
            hostedMp3SearchResults.innerHTML = '<div class="text-center text-gray-500">Searching...</div>';

            try {
                const response = await fetch(`/search_hosted_mp3s?query=${encodeURIComponent(query)}`);
                const songs = await response.json();

                hostedMp3SearchResults.innerHTML = ''; // Clear previous results

                if (songs.length === 0) {
                    hostedMp3SearchResults.innerHTML = '<div class="text-center text-gray-500 py-4">No songs found.</div>';
                    return;
                }

                songs.forEach(song => {
                    const songItem = document.createElement('div');
                    songItem.className = 'flex items-center justify-between p-2 bg-gray-50 rounded-md shadow-sm hover:bg-gray-100 transition-colors duration-150';
                    songItem.innerHTML = `
                        <div class="flex items-center space-x-3 flex-grow min-w-0">
                            <img src="${song.thumbnail || 'https://placehold.co/40x40/CCCCCC/FFFFFF?text=MP3'}" alt="Thumbnail" class="w-10 h-10 rounded-md object-cover flex-shrink-0">
                            <div class="flex-grow overflow-hidden">
                                <p class="text-sm font-semibold text-gray-800 truncate">${song.title}</p>
                                <p class="text-xs text-gray-500 truncate">${song.artist || 'Unknown Artist'}</p>
                            </div>
                        </div>
                        <button class="add-to-playlist-button px-3 py-1 bg-blue-500 text-white rounded-md text-xs hover:bg-blue-600 transition-colors duration-200 ml-4">
                            <i class="fas fa-plus"></i> Add
                        </button>
                    `;
                    songItem.querySelector('.add-to-playlist-button').addEventListener('click', () => {
                        if (currentJamId && !isHost) {
                            showMessage("Only the host can add songs to the playlist in a jam session.");
                            return;
                        }
                        // Add to local playlist (currentPlaylist)
                        currentPlaylist.push(song);
                        renderPlaylist();
                        showMessage(`Added "${song.title}" to playlist!`);
                        if (currentJamId && isHost) {
                            // If in jam and host, also emit to server to sync
                            socket.emit('add_song_to_jam', { jam_id: currentJamId, song: song });
                        }
                    });
                    hostedMp3SearchResults.appendChild(songItem);
                });
            } catch (error) {
                console.error("Error searching hosted MP3s:", error);
                hostedMp3SearchResults.innerHTML = '<div class="text-center text-red-500 py-4">Failed to load songs.</div>';
            }
        }

        performHostedMp3SearchButton.addEventListener('click', () => performHostedMp3Search(hostedMp3SearchInput.value.trim()));
        hostedMp3SearchInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                performHostedMp3Search(hostedMp3SearchInput.value.trim());
            }
        });

        // --- Initial setup on window load ---
        window.onload = async function() {
            // Dynamically parse Firebase config from the __firebase_config global variable
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
            
            // Check if firebaseConfig is not empty before initializing.
            if (Object.keys(firebaseConfig).length > 0) {
                try {
                    fbApp = firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore(fbApp); // Initialize client-side Firestore
                    console.log("Client-side Firebase (Firestore) initialized.");
                } catch (error) {
                    console.error("Error during Firebase client-side initialization:", error);
                    showMessage(`Client-side Firebase initialization failed: ${error.message}. Jam features may not work.`, 6000);
                    db = null; // Set to null if init fails
                }
            } else {
                console.warn("Firebase config not available. Client-side Firestore will not be initialized.");
                db = null; // Ensure db is null
                showMessage("Firebase configuration missing. Jam features may not work. Please ensure it's configured in your environment.", 6000);
            }

            // Initial UI rendering and handling URL parameters
            resetPlayerUI(); // Ensure controls are enabled for local play by default
            await handleInitialLoadAndJamJoin();
            
            // Pre-fill nicknames
            nicknameInputCreate.value = currentNickname;
            nicknameInputJoin.value = currentNickname;
        };

        // Function to handle initial load and potential jam join via URL
        async function handleInitialLoadAndJamJoin() {
            // Fetch all hosted songs in background for random playback
            fetchAllHostedSongsForRandomPlayback();

            const urlParams = new URLSearchParams(window.location.search);
            const initialJamId = urlParams.get('jam_id');

            if (initialJamId) {
                jamIdInput.value = initialJamId; // Pre-fill the jam ID
                openModal(joinJamModal); // Open join modal
                // For anonymous users, we just pre-fill and let them click.
                // No auto-join for anonymous due to potential endless loops/bad UX if jam doesn't exist.
                showMessage("A Jam ID was found in the URL. Please enter your nickname and click 'Join Jam'.", 5000);
            } else {
                showMessage("Welcome! Use 'Add Songs' or the 3 dots menu to begin.", 3000);
                trackTitle.textContent = "No song loaded";
                artistName.textContent = "";
                albumArt.src = "https://placehold.co/128x128/CCCCCC/FFFFFF?text=No+Track";
            }
        }
    </script>
</body>
</html>
